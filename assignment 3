---
title: "Assignment 3"
author: '49101710'
date: "2023-11-08"
output: html_document
---
ATTCGAC
ATCAC
```{r}
library(dplyr)

seq1 <- "ATCAC"
seq2 <- "ATTCGAC"
match <- 1
mismatch <- -1
gap <- -2

len1 = nchar(seq1)
len2 = nchar(seq2) 
seq1 = unlist(strsplit(seq1, split = "")) 
seq2 = unlist(strsplit(seq2, split = "")) 
  
M = matrix(0, nrow = len1 + 1, ncol = len2 + 1) 
rownames(M) = c("-", seq1)
colnames(M) = c("-", seq2) 
M[1, ] = cumsum(c(0, rep(gap, len2))) 
M[, 1] = cumsum(c(0, rep(gap, len1)))
  
D = matrix(0, nrow = len1 + 1, ncol = len2 + 1) 
rownames(D) = c("-", seq1) 
colnames(D) = c("-", seq2) 
D[1, ] = rep("left") 
D[, 1] = rep("top") 
type = c("dia", "left", "top")
  

for (i in 2:(len1 + 1)){
  for (j in 2:(len2 + 1)){
    left = M[i, j - 1] + gap 
    top = M[i - 1, j] + gap 
    dia = ifelse(rownames(M)[i] == colnames(M)[j], 
                 M[i - 1, j - 1] + match, 
                 M[i - 1, j - 1] + mismatch)
    M[i, j] = max(dia, left, top) 
    D[i, j] = type[which.max(c(dia, left, top))] 
  }
} 
View(M)

align1 = c()
align2 = c() 

while(i > 1 && j > 1){# Note that the values i and j still exist from the previous for loops and therefore will be 
  #carried onto this while loop as the bottom right corner of the matrix or the max row/column values.
    
  if(D[i, j] == "dia") {
    align1 = c(rownames(M)[i], align1)
    align2 = c(colnames(M)[j], align2)
    j = j - 1; i = i - 1 
  } else if (D[i, j] == "top") {
    align1 = c(rownames(M)[i], align1)
    align2 = c("-", align2) 
    i = i - 1 
  } else if (D[i, j] == "left") {
    align1 = c("-", align1) # 
    align2 = c(colnames(M)[j], align2) 
    j = j - 1 # 
  } 
  
}
list(aligned_seqs = matrix(c(align1, align2), byrow = TRUE, nrow = 2),
            score = M[nrow(M), ncol(M)], score_matrix = M, movement_matrix = D)

```
Q3.1
```{r}
read.csv("single_cell_RNA_seq_bam.sam", nrows=73, sep="\t", header=FALSE,
fill=TRUE)
```
RN indicates the reference sequence name while LN indicates the reference sequence length.

Q3.2

The reference sequence length, LN, of chromosome X is 171031299 as seen from the header in page 3 above, row = 22.

Q4.1
```{r}
sam <- read.csv("single_cell_RNA_seq_bam.sam", sep="\t", header=FALSE,
comment.char="@", col.names = paste0("V",seq_len(30)), fill=TRUE)
sam <- sam[paste0("V",seq_len(11))]

dim(sam)

```
There are 146346 reads in the BAM file

Q4.2

```{r}
print(sam[10,])
```
V3 is the column referring to the reference alignment. V11 corresponds to the ASCII of base quality or "QUAL" in the appendix.

Q4.3
```{r}
align_X <- sum(sam$V3 == "X")
align_X
```
There are 5999 reads that are aligned to chromosome X

Q4.4

```{r}
count <- strsplit(sam[3, 11], "")
lengths(count) # 58 base quality scores
sam_X <- sam[(sam$V3 == "X"), ]
meanBQ <- list()
for (i in 1:5999){
  
  temp <- utf8ToInt(sam_X[i, 11]) - 33
  
  meanBQ[i] <- sum(temp) / 58
  
}
total_meanX <- sum(unlist(meanBQ)) / 5999
```
The mean Base Quality scores are contained in the list called "meanBQ"
Mean of all reads is under "total_meanX"

Q4.5

```{r}
temp1 <- matrix(NA, nrow = 146346, ncol = 58)
for (i in 1:146346){
  
  temp <- unlist(strsplit(sam$V11[i], split = ""))
  
  for (m in 1:58){
  
    tempo <- utf8ToInt(temp[m]) - 33
    
    temp1[i, m] <- tempo
    
  }
}
temp1 <- as.data.frame(temp1)

library(ggplot2)
library(reshape2)
summary_stats <- as.data.frame(summary(temp1))

quantiles <- apply(temp1, 2, quantile, probs = c(0, 0.25, 0.5, 0.75, 1))

melted_data <- melt(quantiles, varnames = c("Quantile", "Variable"))

ggplot(melted_data, aes(x = Variable, y = value)) +
  geom_boxplot() +
  labs(title = "Boxplot of Quantiles for Each Base",
       x = "Base",
       y = "Base Score") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) + theme_minimal() + 
  scale_x_discrete(breaks = unique(melted_data$Variable)
                   [seq(1, length(unique(melted_data$Variable)), 5)])

```
Q4.6

column 4 contains the leftmost mapping position, POS or V4.

Q4.7

```{r}
sam_BAM <- sam[(sam$V3 == 9 & sam$V4 >= 40801273 & sam$V4 <= 40805199), ]
dim(sam_BAM)

```
119 reads are located on chromosome 9 within the specified locations.

Q4.8

```{r}
sam_Map <- sam[(sam$V5 < 50), ]
dim(sam_Map)
```
61527 reads have MAPQ less than 50.

Q4.9

```{r}
mean_Map <- mean(sam_Map$V5)
mean_Map
```
mean MAPQ is 0.2418125 if we do not have to do the log conversion and taking the integer as the MAPQ reading.

Q4.10
```{r}

sam_Tomato <- sam[(sam$V3 == "tdTomato"), ]
dim(sam_Tomato)
```
There are a total of 63 reads that align to tdTomato. As the hint suggests, the fluorescent marker could be used for studying cell populations under a microscope, where movements of the cell are visible through the fluorescence and we would then be able to label or mark them. The cell would emit fluoroscence if the reads are accurate since they are tagged with the fluorescent marker which would reflect or shine light when a certain wavelength of light is shined onto them. But on a sample of 146346 cells, 63 affected cells are very limited and would be hard to spot but none the less possible.

Q5.1

```{r}
vcf_con <- file("RNA_seq_annotated_variants.vcf", open="r")
vcf_file <- readLines(vcf_con)
close(vcf_con)
vcf <- data.frame(vcf_file)
header <- vcf[grepl("##", vcf$vcf_file), ]
factor(header)
variants <- read.csv("RNA_seq_annotated_variants.vcf", skip=length(header),
header=TRUE, sep="\t")
```
reference allele: G
alternative allele: A

Q5.2

```{r}

Qfp2 <- strsplit(as.character(variants[1,8]), split = ";")
Qfp2 <- strsplit(unlist(Qfp2), split = ",")
print(Qfp2)
```

Q5.3

Same as above code. Using the first line post "ANN", we can see the alternative "A" is an intron variant used in a transcript for protein coding, what 2/21 is after protein coding probably signifies the specific protein or the index in the chain of production in the transcript. Also has a "MODIFIER" putative impact which indicates the variant type, which can be seen in the VCF annotation appendix where different variant types are categorized into MODIFIER, MODERATE, LOW, and HIGH.

Q5.4

```{r}

Qfp4 <- strsplit(as.character(variants[683,8]), split = ";")
Qfp4 <- strsplit(unlist(Qfp4), split = ",")
print(Qfp4)
```
reference: ACAGGGG, Alternative: A. According to the first line again, the annotation says the alternative "A" is a frameshift variant, meaning it induces frameshift, a splice acceptor variant, splice region variant, and an intron variant where putative impact is "HIGH". It is a transcript used for protein coding as the questions before.Variant has also been realigned to the 3' position within the transcript to comply with HGVS specification. In this case, the gene "RPS19" is affected.

Q5.5

Assuming we are to categorize these variants in terms of punitive impact: HIGH, MODERATE, MODIFIER, or LOW.

```{r}
df <- as.character((variants$INFO))
df <- as.data.frame(df)
for(i in 1:836){
  df[i,2] <- grepl("HIGH", df[i,1])  
  df[i,3] <- grepl("MODERATE", df[i,1])
  df[i,4] <- grepl("LOW", df[i,1])
  df[i,5] <- grepl("MODIFIER", df[i,1])
  df[i,6] <- grepl("protein_coding", df[i,1])
}

dfH <- grep("TRUE", df$V2)
dfME <- grep("TRUE", df$V3)
dfL <- grep("TRUE", df$V4)
dfMR <- grep("TRUE", df$V5)
length(dfH)
length(dfME)
length(dfL)
length(dfMR)
```
4 HIGH, 74 Moderate, 44 LOW, and 819 MODIFIER punitive impact variants. Notice how the sum of the categories add up to more than 836, the total amount of variants. This is because one variant may have a combination of traits or categories.

Q5.6

A frameshift variant is when the the mutation or variant changes the reading frame of the entire read. It would have a greater effect on the resultant protein than a missense read. Missense read is a mutation in one or more bases/nucleotide possibily resulting in the change of one amino acid in the traslation sequence. Depending on the number of bases mutated, a frameshift variant would have a greater effect since a missense, if small, would only effect the production of a single or two amino acids making a different protein overall or possibly the same one. A shift in reading frame makes it so the possibility of making the same protein is drastically reduced since this shift would change the set codons in the rest of the transcript.

Q5.7 

```{r}

df1 <- as.data.frame(as.character((variants$INFO)))
for (i in 1:836){
  df1[i,2] <- grepl("intron_variant", df1[i,1])
  
}
total_intron_variant <- sum(df1$V2 == TRUE)
total_intron_variant
```
There is a total of 476 variants that are labeled as intron variants out of a total of 836 variants. Assuming there is no overlap between intronic and exonic variants...

Q5.8

filter the dataset in question 5.5 to have the HIGH column as TRUE and protein_coding column as TRUE

```{r}
df2 <- df[(df$V2 == TRUE & df$V6 == TRUE),]
head(df2)
```
The listed variants are the ones that have been categorized as high punitive impact.
respectively, genes Ddx1, Rps14, Rps19, Hnrlpl have been highly affected.
The last three genes had either an incomplete transcript, no stop or start codon, realignment, or a combination of mentioned error lines.

Q5.9

Strelka, like other variant calling methods, rely on short read alignments. Having a 60bp read is stretching it already and searching for insertions would mean the bp would be greater than 60 making it too long for the variant caller. If the insertion makes the read longer than the read length, then there would be a partial read. Longer insertions may also lead to false negatives since the variant caller may not be accurately able to determine the insertion.

Q5.10

```{r}
dsd <- data.frame(AD = NA, ADV = NA, ADR = NA, ADA = NA, VAF = NA)
ADV <- list()
AD <- list()
ds <- strsplit(as.character(variants$FORMAT), split = ":")
for(i in 1:836){
  AD <- min(grep("AD", ds[[i]]))
  dsd[i,1] <- AD
  dsd[i,2] <- strsplit((variants$ws20171223_MPs_tomatoMuscle8wkQuiescent201), split = ":")[[i]][AD]
}
dss <- strsplit(dsd$ADV, split = ",")

for (i in 1:836){

  dsd[i,3] <- as.integer(dss[[i]][1])
  dsd[i,4] <- as.integer(dss[[i]][2])
  dsd[i,5] <- dsd[i,4] / (dsd[i,3] + dsd[i,4])
}

boxplot(dsd$VAF)

variants$VAF <- dsd$VAF
variants$coding_regions <- df$V6
dsf <- variants[variants$VAF > 0.05,]
dim(dsf)
dsf <- variants[(variants$VAF > 0.05 & variants$coding_regions == TRUE),]
dim(dsf)
```
Out of 836 variant entries, 823 variants have VAF's > 5% or > 0.05
Then 688 variants have a VAF > 0.05 while being in a coding region/protein_coding.

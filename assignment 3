---
title: "Assignment 3"
author: '49101710'
date: "2023-11-08"
output: html_document
---

```{r}
library(dplyr)
needleman = function(seq1, seq2, gap, mismatch, match){
  
  # Stop conditions
  stopifnot(gap <= 0) # check if penalty negative
  stopifnot(mismatch <= 0)  # check if penalty negative
  stopifnot(match >= 0)  # check if score positive
  
  # Initialize col and rownames for matrices
  len1 = nchar(seq1); len2 = nchar(seq2) # Save number of chars in each sequence
  seq1 = unlist(strsplit(seq1, split = "")) # convert seq to character vector
  seq2 = unlist(strsplit(seq2, split = "")) # convert seq to character vector
  
  # Initialize matrix M (for scores)
  M = matrix(0, nrow = len1 + 1, ncol = len2 + 1) # Initialize matrix
  rownames(M) = c("-", seq1) # assign seq chars to matrix names
  colnames(M) = c("-", seq2) # assign seq chars to matrix names
  M[1, ] = cumsum(c(0, rep(gap, len2))) # Fill 1st row with gap penalites
  M[, 1] = cumsum(c(0, rep(gap, len1))) # Fill 1st col with gap penalites
  View(M)
  
  # Initialize matrix D (for directions)
  D = matrix(0, nrow = len1 + 1, ncol = len2 + 1) # Initialize matrix
  rownames(D) = c("-", seq1) # assign seq chars to matrix names
  colnames(D) = c("-", seq2) # assign seq chars to matrix names
  D[1, ] = rep("hor") # Fill 1st row with "hor" for horizontal moves
  D[, 1] = rep("ver") # Fill 1st col with "ver" for vertical moves
  type = c("dia", "hor", "ver") # Lookup vector
  View(D)
  
  # Compute scores and save moves
  for (i in 2:(len1 + 1)){# for every (initially zero) row
    for (j in 2:(len2 + 1)){# for every (initially zero) col
      hor = M[i, j - 1] + gap # horizontal move = gap for seq1
      ver = M[i - 1, j] + gap # vertical move = gap for seq2 
      dia = ifelse(rownames(M)[i] == colnames(M)[j], # diagonal = ifelse(chars equal, match, mismatch) 
                   M[i - 1, j - 1] + match, 
                   M[i - 1, j - 1] + mismatch)
      M[i, j] = max(dia, hor, ver) # Save current (best) score in M
      D[i, j] = type[which.max(c(dia, hor, ver))] # Save direction of move in D
    }
  } 
  View(M)
  
  # Backtracing
  align1 = c(); align2 = c() # Note: length of final alignments is unknown at this point
  
  while(i > 1 && j > 1){
    
    if(D[i, j] == "dia") {
      align1 = c(rownames(M)[i], align1)
      align2 = c(colnames(M)[j], align2)
      j = j - 1; i = i - 1  # update indices
    } else if (D[i, j] == "ver") {
      align1 = c(rownames(M)[i], align1)
      align2 = c("-", align2) # vertical movement = gap for seq2
      i = i - 1 # update indices
    } else if (D[i, j] == "hor") {
      align1 = c("-", align1) # horizontal movement = gap for seq1
      align2 = c(colnames(M)[j], align2) 
      j = j - 1 # update indices
    } 
    
  }
  
  # Prepare output
  return(list(aligned_seqs = matrix(c(align1, align2), byrow = TRUE, nrow = 2),
              score = M[nrow(M), ncol(M)], score_matrix = M, movement_matrix = D))
 
}



needleman("ATTCGAC", "ATCAC", -2, -5, 1)
```

Q4.1
```{r}
sam <- read.csv("single_cell_RNA_seq_bam.sam", sep="\t", header=FALSE,
comment.char="@", col.names = paste0("V",seq_len(30)), fill=TRUE)
sam <- sam[paste0("V",seq_len(11))]

dim(sam)

```
There are 146346 reads in the BAM file

Q4.2

```{r}
print(sam[10,])
```
V3 is the column referring to the reference alignment. V11 corresponds to the ASCII of base quality or "QUAL" in the appendix.

Q4.3
```{r}
align_X <- sum(sam$V3 == "X")
align_X
```
There are 5999 reads that are aligned to chromosome X

Q4.4

```{r}
count <- strsplit(sam[3, 11], "")
lengths(count) # 58 base quality scores
sam_X <- sam[(sam$V3 == "X"), ]
meanBQ <- list()
for (i in 1:5999){
  
  temp <- utf8ToInt(sam_X[i, 11]) - 33
  
  meanBQ[i] <- sum(temp) / 58
  
}
total_meanX <- sum(unlist(meanBQ)) / 5999
```
The mean Base Quality scores are contained in the list called "meanBQ"
Mean of all reads is under "total_meanX"

Q4.5

```{r}
temp1 <- matrix(NA, nrow = 14634, ncol = 58)
for (i in 1:14634){
  
  temp <- unlist(strsplit(sam$V11[i], split = ""))
  
  for (m in 1:58){
  
    tempo <- utf8ToInt(temp[m])
    
    temp1[i, m] <- tempo
    
  }
}
temp1 <- temp1 - 33
temp1 <- as.data.frame(temp1)

library(ggplot2)
library(reshape2)
summary_stats <- as.data.frame(summary(temp1))

quantiles <- apply(temp1, 2, quantile, probs = c(0, 0.25, 0.5, 0.75, 1))

melted_data <- melt(quantiles, varnames = c("Quantile", "Variable"))

ggplot(melted_data, aes(x = Variable, y = value)) +
  geom_boxplot() +
  labs(title = "Boxplot of Quantiles for Each Variable",
       x = "Base",
       y = "Base Score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  scale_x_discrete(breaks = unique(melted_data$Variable)
                   [seq(1, length(unique(melted_data$Variable)), 5)])

```
Q4.6

column 4 contains the leftmost mapping position, POS or V4.

Q4.7

```{r}
sam_BAM <- sam[(sam$V3 == 9 & sam$V4 >= 40801273 & sam$V4 <= 40805199), ]
dim(sam_BAM)

```
119 reads are located on chromosome 9 within the specified locations.

Q4.8

```{r}
sam_Map <- sam[(sam$V5 < 50), ]
dim(sam_Map)
```
61527 reads have MAPQ less than 50.

Q4.9

```{r}
mean_Map <- mean(sam_Map$V5)
mean_Map
```
mean MAPQ is 0.2418125 if we do not have to do the log conversion and taking the integer as the MAPQ reading.

Q4.10
```{r}

sam_Tomato <- sam[(sam$V3 == "tdTomato"), ]
dim(sam_Tomato)
```
There are a total of 63 reads that align to tdTomato. As the hint suggests, the fluorescent marker could be used for studying cell populations under a microscope, where movements of the cell are visible through the fluorescence and we would then be able to label or mark them. The cell would emit fluroscence if the reads are accurate since they are tagged with the fluorescent marker which would reflect or shine light when a certain wavelength of light is shined onto them.

Q5.1

```{r}
vcf_con <- file("RNA_seq_annotated_variants.vcf", open="r")
vcf_file <- readLines(vcf_con)
close(vcf_con)
vcf <- data.frame(vcf_file)
header <- vcf[grepl("##", vcf$vcf_file), ]
factor(header)
variants <- read.csv("RNA_seq_annotated_variants.vcf", skip=length(header),
header=TRUE, sep="\t")
```
reference allele: G
alternative allele: A

Q5.2

```{r}

Qfp2 <- strsplit(as.character(variants[1,8]), split = ";")
Qfp2 <- strsplit(unlist(Qfp2), split = ",")
print(Qfp2)
```
I might not have needed to seperate with the use of commas but it seemed much more readable. Also, the value for after "ANN" is everything above.
I'm confused whether the question is asking whether we should do this for the entire first chromosome variants or just the first row...

Q5.3

Same as above code. Using the first line post "ANN", we can see the alternative "A" is an intron variant used in a transcript for protein coding, what 2/21 is after protein coding probably signifies the specific protein or the place in the chain of production in the transcript. Also has a "MODIFIER" putative impact?

Q5.4

```{r}

Qfp4 <- strsplit(as.character(variants[683,8]), split = ";")
Qfp4 <- strsplit(unlist(Qfp4), split = ",")
print(Qfp4)
```
reference: ACAGGGG, Alternative: A. According to the first line again, the annotation says the alternative "A" is a frameshift variant, meaning it induces frameshift, a splice acceptor variant, splice region variant, and an intron variant where putative impact is "HIGH". It is a transcript used for protein cading as the questions before.Variant has also been realigned to the 3' position within the transcript to comply with HGVS specification. In this case, the gene "RPS19" is affected.

Q5.5

Okay for 5.5 im confused whether we need to do what we did with the previous questions but use R to sort or sum the amount of different kind of variants and give a total for them... 
so for eg:
 out of 836 observations
 400 has frameshifts, 500 has nonsynonymos or synonymous snvs, 300 with missense...

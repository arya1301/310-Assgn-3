---
title: "Assignment 3"
author: '49101710'
date: "2023-11-08"
output: html_document
---

```{r}
library(dplyr)
needleman = function(seq1, seq2, gap, mismatch, match){
  
  # Stop conditions
  stopifnot(gap <= 0) # check if penalty negative
  stopifnot(mismatch <= 0)  # check if penalty negative
  stopifnot(match >= 0)  # check if score positive
  
  # Initialize col and rownames for matrices
  len1 = nchar(seq1); len2 = nchar(seq2) # Save number of chars in each sequence
  seq1 = unlist(strsplit(seq1, split = "")) # convert seq to character vector
  seq2 = unlist(strsplit(seq2, split = "")) # convert seq to character vector
  
  # Initialize matrix M (for scores)
  M = matrix(0, nrow = len1 + 1, ncol = len2 + 1) # Initialize matrix
  rownames(M) = c("-", seq1) # assign seq chars to matrix names
  colnames(M) = c("-", seq2) # assign seq chars to matrix names
  M[1, ] = cumsum(c(0, rep(gap, len2))) # Fill 1st row with gap penalites
  M[, 1] = cumsum(c(0, rep(gap, len1))) # Fill 1st col with gap penalites
  View(M)
  
  # Initialize matrix D (for directions)
  D = matrix(0, nrow = len1 + 1, ncol = len2 + 1) # Initialize matrix
  rownames(D) = c("-", seq1) # assign seq chars to matrix names
  colnames(D) = c("-", seq2) # assign seq chars to matrix names
  D[1, ] = rep("hor") # Fill 1st row with "hor" for horizontal moves
  D[, 1] = rep("ver") # Fill 1st col with "ver" for vertical moves
  type = c("dia", "hor", "ver") # Lookup vector
  View(D)
  
  # Compute scores and save moves
  for (i in 2:(len1 + 1)){# for every (initially zero) row
    for (j in 2:(len2 + 1)){# for every (initially zero) col
      hor = M[i, j - 1] + gap # horizontal move = gap for seq1
      ver = M[i - 1, j] + gap # vertical move = gap for seq2 
      dia = ifelse(rownames(M)[i] == colnames(M)[j], # diagonal = ifelse(chars equal, match, mismatch) 
                   M[i - 1, j - 1] + match, 
                   M[i - 1, j - 1] + mismatch)
      M[i, j] = max(dia, hor, ver) # Save current (best) score in M
      D[i, j] = type[which.max(c(dia, hor, ver))] # Save direction of move in D
    }
  } 
  View(M)
  
  # Backtracing
  align1 = c(); align2 = c() # Note: length of final alignments is unknown at this point
  
  while(i > 1 && j > 1){
    
    if(D[i, j] == "dia") {
      align1 = c(rownames(M)[i], align1)
      align2 = c(colnames(M)[j], align2)
      j = j - 1; i = i - 1  # update indices
    } else if (D[i, j] == "ver") {
      align1 = c(rownames(M)[i], align1)
      align2 = c("-", align2) # vertical movement = gap for seq2
      i = i - 1 # update indices
    } else if (D[i, j] == "hor") {
      align1 = c("-", align1) # horizontal movement = gap for seq1
      align2 = c(colnames(M)[j], align2) 
      j = j - 1 # update indices
    } 
    
  }
  
  # Prepare output
  return(list(aligned_seqs = matrix(c(align1, align2), byrow = TRUE, nrow = 2),
              score = M[nrow(M), ncol(M)], score_matrix = M, movement_matrix = D))
 
}



needleman("ATTCGAC", "ATCAC", -2, -5, 1)
```
Q3.1
```{r}
read.csv("single_cell_RNA_seq_bam.sam", nrows=73, sep="\t", header=FALSE,
fill=TRUE)
```
RN indicates the reference sequence name while LN indicates the reference sequence length.

Q3.2

The reference sequence length, LN, of chromosome X is 171031299 as seen from the header in page 3 above, row = 22.

Q4.1
```{r}
sam <- read.csv("single_cell_RNA_seq_bam.sam", sep="\t", header=FALSE,
comment.char="@", col.names = paste0("V",seq_len(30)), fill=TRUE)
sam <- sam[paste0("V",seq_len(11))]

dim(sam)

```
There are 146346 reads in the BAM file

Q4.2

```{r}
print(sam[10,])
```
V3 is the column referring to the reference alignment. V11 corresponds to the ASCII of base quality or "QUAL" in the appendix.

Q4.3
```{r}
align_X <- sum(sam$V3 == "X")
align_X
```
There are 5999 reads that are aligned to chromosome X

Q4.4

```{r}
count <- strsplit(sam[3, 11], "")
lengths(count) # 58 base quality scores
sam_X <- sam[(sam$V3 == "X"), ]
meanBQ <- list()
for (i in 1:5999){
  
  temp <- utf8ToInt(sam_X[i, 11]) - 33
  
  meanBQ[i] <- sum(temp) / 58
  
}
total_meanX <- sum(unlist(meanBQ)) / 5999
```
The mean Base Quality scores are contained in the list called "meanBQ"
Mean of all reads is under "total_meanX"

Q4.5

```{r}
temp1 <- matrix(NA, nrow = 146346, ncol = 58)
for (i in 1:146346){
  
  temp <- unlist(strsplit(sam$V11[i], split = ""))
  
  for (m in 1:58){
  
    tempo <- utf8ToInt(temp[m]) - 33
    
    temp1[i, m] <- tempo
    
  }
}
temp1 <- as.data.frame(temp1)

library(ggplot2)
library(reshape2)
summary_stats <- as.data.frame(summary(temp1))

quantiles <- apply(temp1, 2, quantile, probs = c(0, 0.25, 0.5, 0.75, 1))

melted_data <- melt(quantiles, varnames = c("Quantile", "Variable"))

ggplot(melted_data, aes(x = Variable, y = value, fill = Variable)) +
  geom_boxplot() +
  labs(title = "Boxplot of Quantiles for Each Variable",
       x = "Base",
       y = "Base Score") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) + theme_minimal() + 
  scale_x_discrete(breaks = unique(melted_data$Variable)
                   [seq(1, length(unique(melted_data$Variable)), 5)])

```
Q4.6

column 4 contains the leftmost mapping position, POS or V4.

Q4.7

```{r}
sam_BAM <- sam[(sam$V3 == 9 & sam$V4 >= 40801273 & sam$V4 <= 40805199), ]
dim(sam_BAM)

```
119 reads are located on chromosome 9 within the specified locations.

Q4.8

```{r}
sam_Map <- sam[(sam$V5 < 50), ]
dim(sam_Map)
```
61527 reads have MAPQ less than 50.

Q4.9

```{r}
mean_Map <- mean(sam_Map$V5)
mean_Map
```
mean MAPQ is 0.2418125 if we do not have to do the log conversion and taking the integer as the MAPQ reading.

Q4.10
```{r}

sam_Tomato <- sam[(sam$V3 == "tdTomato"), ]
dim(sam_Tomato)
```
There are a total of 63 reads that align to tdTomato. As the hint suggests, the fluorescent marker could be used for studying cell populations under a microscope, where movements of the cell are visible through the fluorescence and we would then be able to label or mark them. The cell would emit fluroscence if the reads are accurate since they are tagged with the fluorescent marker which would reflect or shine light when a certain wavelength of light is shined onto them. But on a sample of 146346 cells, 63 affected cells are very limited and would be hard to spot but none the less possible.

Q5.1

```{r}
vcf_con <- file("RNA_seq_annotated_variants.vcf", open="r")
vcf_file <- readLines(vcf_con)
close(vcf_con)
vcf <- data.frame(vcf_file)
header <- vcf[grepl("##", vcf$vcf_file), ]
factor(header)
variants <- read.csv("RNA_seq_annotated_variants.vcf", skip=length(header),
header=TRUE, sep="\t")
```
reference allele: G
alternative allele: A

Q5.2

```{r}

Qfp2 <- strsplit(as.character(variants[1,8]), split = ";")
Qfp2 <- strsplit(unlist(Qfp2), split = ",")
print(Qfp2)
```
I might not have needed to seperate with the use of commas but it seemed much more readable. Also, the value for after "ANN" is everything above.
I'm confused whether the question is asking whether we should do this for the entire first chromosome variants or just the first row...

Q5.3

Same as above code. Using the first line post "ANN", we can see the alternative "A" is an intron variant used in a transcript for protein coding, what 2/21 is after protein coding probably signifies the specific protein or the place in the chain of production in the transcript. Also has a "MODIFIER" putative impact?

Q5.4

```{r}

Qfp4 <- strsplit(as.character(variants[683,8]), split = ";")
Qfp4 <- strsplit(unlist(Qfp4), split = ",")
print(Qfp4)
```
reference: ACAGGGG, Alternative: A. According to the first line again, the annotation says the alternative "A" is a frameshift variant, meaning it induces frameshift, a splice acceptor variant, splice region variant, and an intron variant where putative impact is "HIGH". It is a transcript used for protein cading as the questions before.Variant has also been realigned to the 3' position within the transcript to comply with HGVS specification. In this case, the gene "RPS19" is affected.

Q5.5

Okay for 5.5 im confused whether we need to do what we did with the previous questions but use R to sort or sum the amount of different kind of variants and give a total for them... 
so for eg:
 out of 836 observations
 400 has frameshifts, 500 has nonsynonymos or synonymous snvs, 300 with missense...
Assuming we are to categorize these variants in terms of punitive impact: HIGH, MODERATE, MODIFIER, or LOW.

```{r}
df <- as.character((variants$INFO))
df <- as.data.frame(df)
for(i in 1:836){
  df[i,2] <- grepl("HIGH", df[i,1])  
  df[i,3] <- grepl("MODERATE", df[i,1])
  df[i,4] <- grepl("LOW", df[i,1])
  df[i,5] <- grepl("MODIFIER", df[i,1])
  df[i,6] <- grepl("protein_coding", df[i,1])
}

dfH <- grep("TRUE", df$V2)
dfME <- grep("TRUE", df$V3)
dfL <- grep("TRUE", df$V4)
dfMR <- grep("TRUE", df$V5)
length(dfH)
length(dfME)
length(dfL)
length(dfMR)
```
4 HIGH, 74 Moderate, 44 LOW, and 819 MODIFIER punitive impact variants.

Q5.6

A frameshift variant is when the the mutation or variant changes the reading frame of the entire read. It would have a greater effect on the resultant protein than a missense read. Missense read is a mutation in one or more bases/nucleotide possibily resulting in the change of one amino acid in the traslation sequence. Depending on the number of bases mutated, a frameshift variant would have a greater effect since a missense, if small, would only effect the production of a single or two amino acids making a different protein overall or possibly the same one. A shift in reading frame makes it so the possibility of making the same protein is drastically reduced since this shift would change the set codons in the rest of the transcript.

Q5.7 

```{r}

df1 <- as.data.frame(as.character((variants$INFO)))
for (i in 1:836){
  df1[i,2] <- grepl("intron_variant", df1[i,1])
  
}
total_intron_variant <- sum(df1$V2 == TRUE)
total_intron_variant
```
There is a total of 476 variants that are labeled as intron variants out of a total of 836 variants. Assuming there is no overlap between intronic and exonic variants...

Q5.8

filter the dataset in question 5.5 to have the HIGH column as TRUE

```{r}
df2 <- df[(df$V2 == TRUE & df$V6 == TRUE),]
head(df2)
```
The listed variants are the ones that have been categorized as high punitive impact.
respectively, genes Ddx1, Rps14, Rps19, Hnrlpl have been highly affected.
The last three genes had either an incomplete transcript, no stop or start codon, realignment, or a combination of mentioned error lines.

Q5.9

Strelka, like other variant calling methods, rely on short read alignments. Having a 60bp read is stretching it already and searching for insertions would mean the bp would be greater than 60 making it too long for the variant caller. If the insertion makes the read longer than the read length, then there would be a partial read. Longer insertions may also lead to false negatives since the variant caller may not be accurately able to determine the insertion.

Q5.10

```{r}
dsd <- data.frame(AD = NA, ADV = NA, ADR = NA, ADA = NA, VAF = NA)
ADV <- list()
AD <- list()
ds <- strsplit(as.character(variants$FORMAT), split = ":")
for(i in 1:836){
  AD <- min(grep("AD", ds[[i]]))
  dsd[i,1] <- AD
  dsd[i,2] <- strsplit((variants$ws20171223_MPs_tomatoMuscle8wkQuiescent201), split = ":")[[i]][AD]
}
dss <- strsplit(dsd$ADV, split = ",")

for (i in 1:836){

  dsd[i,3] <- as.integer(dss[[i]][1])
  dsd[i,4] <- as.integer(dss[[i]][2])
  dsd[i,5] <- dsd[i,4] / (dsd[i,3] + dsd[i,4])
}
boxplot(dsd$VAF)


```
